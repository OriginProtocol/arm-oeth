# Oracle Exploitation

Attacks targeting the price feeds that lending and derivatives protocols rely on for collateral valuation, liquidation thresholds, and position sizing. The attacker manipulates the price the protocol reads — either through misconfigured Chainlink feeds, manipulable LP NFT position valuations, or artificial fee accumulation. 4 incidents in 2025, up to $1M (Moonwell).

**Severity**: High
**Checklist IDs**: D3, D4, D5, O1, O2, O3, O4, O5, O6, O7
**Code Characteristics**: lending, borrowing, derivatives, oracle-consumer, collateral valuation

## Root Cause

The protocol's price oracle returns a value that does not reflect the true economic value of the asset, either because:

1. **Mismatched oracle feed** — the Chainlink feed is for a different (similarly named) asset than what the market actually lists. Wrapped/derivative tokens are common sources of mismatch.

2. **Manipulable LP position valuation** — LP NFT positions are accepted as collateral, but their value includes components (accumulated fees, concentrated liquidity tick range) that can be artificially inflated within a single block.

3. **Fee accumulation manipulation** — the protocol values LP positions including unclaimed fees. An attacker generates massive fees via flash-loan-funded back-and-forth swaps through a concentrated position, inflating its apparent value.

## Vulnerable Code Pattern

```solidity
// VULNERABLE — wrong oracle feed for wrapped token
function getPrice(address token) public view returns (uint256) {
    // Market lists wrsETH, but oracle returns price for rsETH (different wrapper)
    (, int256 price,,,) = chainlinkFeed.latestRoundData();
    return uint256(price);  // price is for wrong asset!
}

// VULNERABLE — LP position value includes manipulable fees
function getPositionValue(uint256 tokenId) public view returns (uint256) {
    (uint256 amount0, uint256 amount1) = positionManager.positions(tokenId);
    (uint256 fee0, uint256 fee1) = positionManager.collect(tokenId);
    // fees can be artificially inflated by flash-loan-funded swaps
    return (amount0 + fee0) * price0 + (amount1 + fee1) * price1;
}
```

### Variants

**Variant A — Mismatched Chainlink feed (Moonwell, ~$1M):**
```solidity
// Moonwell listed wrsETH as collateral
// But oracle returned price for a different rsETH wrapper
// Attacker: flash-loan wrsETH → deposit as collateral at inflated valuation
//          → over-borrow wstETH → repay flash loan
```

**Variant B — NFT LP position as inflated collateral (Paribus, ~$86K):**
```solidity
// Paribus accepted Camelot V3 LP NFT positions as collateral
// Attacker: flash-loan USDT → buy PBX tokens → create LP NFT
//          → enter as collateral in lending market
//          → borrow ETH, ARB, WBTC, USDT against inflated LP value
```

**Variant C — Fee accumulation manipulation (ImpermaxV3, ~$300K):**
```solidity
// ImpermaxV3 valued LP positions including accumulated fees
// Attacker: flash-loan WETH+USDC → create concentrated LP position
//          → execute 100+ back-and-forth swaps through the position
//          → each swap generates captured fees
//          → reinvest() credits inflated fees to position
//          → borrow against inflated position value
```

## Detection Heuristic

- [ ] Does the protocol use a Chainlink feed? Is the feed address verified to match the exact token being priced (not a wrapper or derivative)?
- [ ] Does the protocol accept LP NFT positions as collateral? Can position value be manipulated within a single block?
- [ ] Does collateral valuation include accumulated/unclaimed fees or rewards?
- [ ] Is there a TWAP or minimum observation period, or is spot price used directly?
- [ ] Can an attacker create a new collateral position and use it in the same transaction?
- [ ] Does the protocol validate that price feeds are not stale (timestamp check)?

If spot LP value used as collateral oracle: **High**. If feed mismatch on mainnet lending protocol: **Critical**.

## Fix / Mitigation

1. **Strict oracle-to-token mapping verification** — audit that each feed matches the exact token contract:
   ```solidity
   // Verify in deployment/configuration
   require(feedToken == marketToken, "oracle mismatch");
   ```

2. **TWAP-based LP valuation** — use time-weighted position values, not spot:
   ```solidity
   uint256 twapValue = getTwapPositionValue(tokenId, TWAP_WINDOW);
   ```

3. **Exclude unclaimed fees from collateral valuation:**
   ```solidity
   // Only count principal liquidity, not accumulated fees
   (uint128 liquidity,,,,) = positionManager.positions(tokenId);
   uint256 value = calculateValueFromLiquidity(liquidity, sqrtPriceX96);
   ```

4. **Multi-block collateral seasoning** — require N blocks before collateral can be borrowed against:
   ```solidity
   require(block.number > depositBlock[tokenId] + SEASONING_PERIOD);
   ```

5. **Price deviation circuit breakers:**
   ```solidity
   uint256 spotPrice = getSpotPrice();
   uint256 twapPrice = getTwapPrice();
   require(spotPrice * 100 / twapPrice > 95 && spotPrice * 100 / twapPrice < 105);
   ```

## Proof (2025 Incidents)

| Protocol | Date | Loss | Variant | PoC |
|----------|------|------|---------|-----|
| Moonwell | 2025 | ~$1M | A: Mismatched Chainlink feed (wrsETH) | [DeFiHackLabs](https://github.com/SunWeb3Sec/DeFiHackLabs) |
| Paribus | 2025-01 | ~$86K | B: Camelot V3 NFT LP as inflated collateral | `2025-01/Paribus_exp.sol` |
| ImpermaxV3 | 2025-04 | ~$300K | C: 100+ swaps inflate fee-inclusive LP value | `2025-04/ImpermaxV3_exp.sol` |

## Related Patterns

- [price-manipulation](./price-manipulation.md) — price manipulation via AMM spot reserves is a subcategory of oracle exploitation
- [flash-loan-amplification](./flash-loan-amplification.md) — flash loans fund the fee generation and position inflation
- [share-price-inflation](./share-price-inflation.md) — inflated vault share prices used as oracles
