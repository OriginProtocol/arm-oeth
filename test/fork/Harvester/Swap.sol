/// SPDX-License-Identifier: MIT
pragma solidity 0.8.23;

import {Sonic} from "contracts/utils/Addresses.sol";
import {SonicHarvester} from "contracts/SonicHarvester.sol";

import {Fork_Shared_Test} from "test/fork/Harvester/shared/Shared.sol";

contract Fork_Concrete_Harvester_Swap_Test_ is Fork_Shared_Test {
    address public constant OS_WHALE = 0x9F0dF7799f6FDAd409300080cfF680f5A23df4b1;

    ////////////////////////////////////////////////////
    /// --- SETUP
    ////////////////////////////////////////////////////
    function setUp() public virtual override {
        super.setUp();

        // Mock call on the oracle to return 1:1
        vm.mockCall(oracle, abi.encodeWithSignature("price(address)"), abi.encode(1 ether));
    }

    ////////////////////////////////////////////////////
    /// --- REVERTS
    ////////////////////////////////////////////////////
    function test_RevertWhen_Swap_Because_InvalidSwapRecipient() public {
        //bytes memory data = getFlyTradeQuote({
        //    from: "OS",
        //    to: "WS",
        //    amount: 1,
        //    slippage: "0.01",
        //    swapper: address(harvester),
        //    recipient: deployer
        //});

        // This is approx the data that should be return from the call on the API, but to avoid too much API call we store it.
        bytes memory data =
            hex"022200e0ae0bdc4eeac5e950b67c6819b118761caaf61946b1e25689d55734fd3fffc939c4c3eb52dff8a794039e2fb66102314ce7b64ce5ce3e5183bc94ad38e000d4c000d9f800e2c000e456f053c684bb01e4cf6d46e41bfe7278a8755eae85c327d9304b6b8f8c025edd1e7d859b963e2e666e5fd9975f0cc37999d816a0e3822b32677670e1748bd7991b0000e06811c15fc00dd468809e587294f800c00de0b6b3a7640000060300e3128acb08000000000000000000000000fffd8963efd1fc6a506488495d951d5263988d2500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000014b1e25689d55734fd3fffc939c4c3eb52dff8a7940000000000000000000000000100f00603008a0300e30400f40080ba2a98f0e04b8d659698c8c891f61a6c604e459e00070a0000000000000000000000000000000000000000000000000000000000000301970500000200700002060707060000000000000000000000000000000000000000000000000000000301c10500600300d800020a0b00000000000000000000000000000000000000000000000000000000000301eb0500800300d8eda49bce2f38d284f839be1f4f2e23e6c7cc7dbd0200700202150500a00005060708070000000000000000000000000000000000000000000000000000000302320500800300d80500600200700200480500c002000000ec00f0000000004001740183018307002001b801be000006002001be01c1000008002001e201eb0000070020020c021500000300000229023200000800200253025f0000030000025f02680000";

        vm.expectRevert(
            abi.encodeWithSelector(SonicHarvester.InvalidSwapRecipient.selector, deployer), address(harvester)
        );
        vm.prank(governor);
        harvester.swap(SonicHarvester.SwapPlatform.Magpie, address(os), 1e18, data);
    }

    function test_RevertWhen_Swap_Because_InvalidFromAsset() public {
        // bytes memory data = getFlyTradeQuote({
        //    from: "OS",
        //    to: "WS",
        //    amount: 1,
        //    slippage: "0.01",
        //    swapper: address(harvester),
        //    recipient: address(harvester)
        // });

        // This is approx the data that should be return from the call on the API, but to avoid too much API call we store it.
        bytes memory data =
            hex"022b00e08ad159a275aee56fb2334dbb69036e9c7bacee9bb1e25689d55734fd3fffc939c4c3eb52dff8a794039e2fb66102314ce7b64ce5ce3e5183bc94ad38e000d4c000d9f800e2c000e4861f5283f7651f412bc1ff1e49be8c5db0b7e3b34edbd88e96a173d1b4af59c806d2a93cc90ac27d9cd1aa6fd9b9334473a3186072c07a5f9949d56a4bd392821b0000e06837087fc00db0857ea8a1034bf800c00de0b6b3a7640000060300e3128acb08000000000000000000000000fffd8963efd1fc6a506488495d951d5263988d2500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000014b1e25689d55734fd3fffc939c4c3eb52dff8a7940000000000000000000000000100f00603008a0300e30400f400800c9a698ed5422eae47ce0b4096496b1fa7771d7d00070a000000000000000000000000000000000000000000000000000000000000030197050000020070000206070706000000000000000000000000000000000000000000000000000000c00dd3ebb111c441630301c10500600301e200020a0b00000000000000000000000000000000000000000000000000000000000301f40500800301e2eda49bce2f38d284f839be1f4f2e23e6c7cc7dbd02007002021e0500a000050607080700000000000000000000000000000000000000000000000000000003023b0500800301e20500600200700200480500c002000000ec00f0000000004001740183018307002001b801be000006002001be01c1000008002001eb01f400000700200215021e00000300000232023b0000080020025c02680000030000026802710000";

        vm.expectRevert(
            abi.encodeWithSelector(SonicHarvester.InvalidFromAsset.selector, address(os)), address(harvester)
        );
        vm.prank(governor);
        harvester.swap(SonicHarvester.SwapPlatform.Magpie, address(ws), 1e18, data);
    }

    function test_RevertWhen_Swap_Because_InvalidToAsset() public {
        // bytes memory data = getFlyTradeQuote({
        //     from: "OS",
        //     to: "SILO",
        //     amount: 1,
        //     slippage: "0.01",
        //     swapper: address(harvester),
        //     recipient: address(harvester)
        // });

        // This is approx the data that should be return from the call on the API, but to avoid too much API call we store it.
        bytes memory data =
            hex"029901808ad159a275aee56fb2334dbb69036e9c7bacee9bb1e25689d55734fd3fffc939c4c3eb52dff8a794b098afc30fce67f1926e735db6fdadfe433e61dbe000d4c000d9f800e2c000e4ffccce4e4d6b1f50588624d40e7352eb0b708182b65e0d5d1a2dabc602f91f5404ca7a3a971f2d259cac2e183d51900ae5ec155ff653b0ead298f8578f3674871c0000e068835c86c09128f40ad4840430f800c00de0b6b3a7640000060300e3128acb08000000000000000000000000fffd8963efd1fc6a506488495d951d5263988d2500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000014b1e25689d55734fd3fffc939c4c3eb52dff8a7940000000000000000000000000100f00603008a0300e30400f400800c9a698ed5422eae47ce0b4096496b1fa7771d7d00070a000000000000000000000000000000000000000000000000000000000000030197050000039e2fb66102314ce7b64ce5ce3e5183bc94ad38a30db08e1ace7c23ae959e1d2e3584b8e3b1858a0201be0201d20500400902f1ac0101ef70a082310101f60201d200020a0b00000000000000000000000000000000000000000000000000000000000302000500a0050060f140a35a01022a0500c00201be022c0d9ff88001023703008a0500e00603023b03008a020070000206070706000000000000000000000000000000000000000000000000000000c091e3b11676633b86030250050100030271030200050120030271eda49bce2f38d284f839be1f4f2e23e6c7cc7dbd02007002028c0501400005060708070000000000000000000000000000000000000000000000000000000302a905012003027105010002007002004805016002000000ec00f0000000004001740183018307002001b801be000003000001e601ef000000004001f301f601d200002001fa020001be0700200221022a0000000020022e023701d2000000023d024d01d2060020024d02500000080020027a028300000700200283028c000003000002a002a9000008002002ca02d6000003000002d602df0000";

        vm.expectRevert(abi.encodeWithSelector(SonicHarvester.InvalidToAsset.selector, Sonic.SILO), address(harvester));
        vm.prank(governor);
        harvester.swap(SonicHarvester.SwapPlatform.Magpie, address(os), 1e18, data);
    }

    function test_RevertWhen_Swap_Because_InvalidFromAssetAmount() public {
        // bytes memory data = getFlyTradeQuote({
        //    from: "OS",
        //    to: "WS",
        //    amount: 1,
        //    slippage: "0.01",
        //    swapper: address(harvester),
        //    recipient: address(harvester)
        // });

        // This is approx the data that should be return from the call on the API, but to avoid too much API call we store it.
        bytes memory data =
            hex"022b00e08ad159a275aee56fb2334dbb69036e9c7bacee9bb1e25689d55734fd3fffc939c4c3eb52dff8a794039e2fb66102314ce7b64ce5ce3e5183bc94ad38e000d4c000d9f800e2c000e4b98ddc7dca11c621a719e617d2d603744db745ad4ba995cd6db2129e2309c36867c7eafa59d21060c4432d198dc7f61d99b7b3f9b7c4c14a61e8465a76ab12011c0000e068837aeac00dc72e46a150d52cf800c00de0b6b3a7640000060300e3128acb08000000000000000000000000fffd8963efd1fc6a506488495d951d5263988d2500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000014b1e25689d55734fd3fffc939c4c3eb52dff8a7940000000000000000000000000100f00603008a0300e30400f400800c9a698ed5422eae47ce0b4096496b1fa7771d7d00070a000000000000000000000000000000000000000000000000000000000000030197050000020070000206070706000000000000000000000000000000000000000000000000000000c00dd8e7c13234eff90301c10500600301e200020a0b00000000000000000000000000000000000000000000000000000000000301f40500800301e2eda49bce2f38d284f839be1f4f2e23e6c7cc7dbd02007002021e0500a000050607080700000000000000000000000000000000000000000000000000000003023b0500800301e20500600200700200480500c002000000ec00f0000000004001740183018307002001b801be000006002001be01c1000008002001eb01f400000700200215021e00000300000232023b0000080020025c02680000030000026802710000";

        vm.expectRevert(
            abi.encodeWithSelector(SonicHarvester.InvalidFromAssetAmount.selector, 1 ether), address(harvester)
        );
        vm.prank(governor);
        harvester.swap(SonicHarvester.SwapPlatform.Magpie, address(os), 2e18, data);
    }

    function test_RevertWhen_Swap_Because_SlippageError() public {
        vm.prank(OS_WHALE);
        os.transfer(address(harvester), 1 ether);

        //bytes memory data = getFlyTradeQuote({
        //    from: "OS",
        //    to: "WS",
        //    amount: 1,
        //    slippage: "0.01",
        //    swapper: address(harvester),
        //    recipient: address(harvester)
        //});

        // This is approx the data that should be return from the call on the API, but to avoid too much API call we store it.
        bytes memory data =
            hex"022b00e08ad159a275aee56fb2334dbb69036e9c7bacee9bb1e25689d55734fd3fffc939c4c3eb52dff8a794039e2fb66102314ce7b64ce5ce3e5183bc94ad38e000d4c000d9f800e2c000e4720a036b41279aa87e17749d582ba9b3f9d99ae2067b655c869386b0e2529816475b97a74fc6a782b31f1c1f547e3ed840c83019e4f0e7b1b1bb642339fb39941c0000e0688383d7c00db5779d3e951389f800c00de0b6b3a7640000060300e3128acb08000000000000000000000000fffd8963efd1fc6a506488495d951d5263988d2500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000014b1e25689d55734fd3fffc939c4c3eb52dff8a7940000000000000000000000000100f00603008a0300e30400f400800c9a698ed5422eae47ce0b4096496b1fa7771d7d00070a000000000000000000000000000000000000000000000000000000000000030197050000020070000206070706000000000000000000000000000000000000000000000000000000c00dd8ea99a93c13bc0301c10500600301e200020a0b00000000000000000000000000000000000000000000000000000000000301f40500800301e2eda49bce2f38d284f839be1f4f2e23e6c7cc7dbd02007002021e0500a000050607080700000000000000000000000000000000000000000000000000000003023b0500800301e20500600200700200480500c002000000ec00f0000000004001740183018307002001b801be000006002001be01c1000008002001eb01f400000700200215021e00000300000232023b0000080020025c02680000030000026802710000";

        // Mock call on the oracle to return 2:1
        vm.mockCall(oracle, abi.encodeWithSignature("price(address)"), abi.encode(2 ether));
        // As this is not easy to have the value returned from `swapWithMagpieSignature` we do a partialRevert (i.e. without arguments)
        vm.expectPartialRevert(SonicHarvester.SlippageError.selector);
        vm.prank(governor);
        harvester.swap(SonicHarvester.SwapPlatform.Magpie, address(os), 1e18, data);
    }

    ////////////////////////////////////////////////////
    /// --- TESTS
    ////////////////////////////////////////////////////
    function test_Swap_WithMagpie_WithOracle() public {
        vm.prank(OS_WHALE);
        os.transfer(address(harvester), 1 ether);

        // Get the quote from the API
        // bytes memory data = getFlyTradeQuote({
        //     from: "OS",
        //     to: "WS",
        //     amount: 1,
        //     slippage: "0.01",
        //     swapper: address(harvester),
        //     recipient: address(harvester)
        // });

        // This is approx the data that should be return from the call on the API, but to avoid too much API call we store it.
        bytes memory data =
            hex"022b00e08ad159a275aee56fb2334dbb69036e9c7bacee9bb1e25689d55734fd3fffc939c4c3eb52dff8a794039e2fb66102314ce7b64ce5ce3e5183bc94ad38e000d4c000d9f800e2c000e493fb6e9d526e4ed4216b2d9b747c6d90198427f65e685424dc1c1101a0a110de1c3cc491d7c9a679040250f0ca9392cb5c374358971fdd791cbfcebe506d8c8b1c0000e06883831cc00db5779d3e951389f800c00de0b6b3a7640000060300e3128acb08000000000000000000000000fffd8963efd1fc6a506488495d951d5263988d2500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000014b1e25689d55734fd3fffc939c4c3eb52dff8a7940000000000000000000000000100f00603008a0300e30400f400800c9a698ed5422eae47ce0b4096496b1fa7771d7d00070a000000000000000000000000000000000000000000000000000000000000030197050000020070000206070706000000000000000000000000000000000000000000000000000000c00dd8ea99a93c13bc0301c10500600301e200020a0b00000000000000000000000000000000000000000000000000000000000301f40500800301e2eda49bce2f38d284f839be1f4f2e23e6c7cc7dbd02007002021e0500a000050607080700000000000000000000000000000000000000000000000000000003023b0500800301e20500600200700200480500c002000000ec00f0000000004001740183018307002001b801be000006002001be01c1000008002001eb01f400000700200215021e00000300000232023b0000080020025c02680000030000026802710000";

        uint256 balanceOSBefore = os.balanceOf(address(harvester));
        uint256 balanceWSBefore = ws.balanceOf(operator);
        assertGe(balanceOSBefore, 1 ether, "Balance of OS before swap should be >= 1");

        vm.startPrank(governor);
        harvester.swap(SonicHarvester.SwapPlatform.Magpie, address(os), 1e18, data);
        vm.stopPrank();
        uint256 balanceOSAfter = os.balanceOf(address(harvester));
        uint256 balanceWSAfter = ws.balanceOf(operator);

        assertEq(balanceOSAfter, 0, "Balance of OS after swap should be 0");
        assertApproxEqRel(balanceWSAfter - balanceWSBefore, 1 ether, 1e16, "Balance of WS after swap should be 1");
    }

    function test_Swap_WithMagpie_WithoutOracle() public {
        vm.prank(OS_WHALE);
        os.transfer(address(harvester), 1 ether);

        // Get the quote from the API
        // bytes memory data = getFlyTradeQuote({
        //     from: "OS",
        //     to: "WS",
        //     amount: 1,
        //     slippage: "0.01",
        //     swapper: address(harvester),
        //     recipient: address(harvester)
        // });

        // This is approx the data that should be return from the call on the API, but to avoid too much API call we store it.
        bytes memory data =
            hex"022b00e08ad159a275aee56fb2334dbb69036e9c7bacee9bb1e25689d55734fd3fffc939c4c3eb52dff8a794039e2fb66102314ce7b64ce5ce3e5183bc94ad38e000d4c000d9f800e2c000e493fb6e9d526e4ed4216b2d9b747c6d90198427f65e685424dc1c1101a0a110de1c3cc491d7c9a679040250f0ca9392cb5c374358971fdd791cbfcebe506d8c8b1c0000e06883831cc00db5779d3e951389f800c00de0b6b3a7640000060300e3128acb08000000000000000000000000fffd8963efd1fc6a506488495d951d5263988d2500000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000014b1e25689d55734fd3fffc939c4c3eb52dff8a7940000000000000000000000000100f00603008a0300e30400f400800c9a698ed5422eae47ce0b4096496b1fa7771d7d00070a000000000000000000000000000000000000000000000000000000000000030197050000020070000206070706000000000000000000000000000000000000000000000000000000c00dd8ea99a93c13bc0301c10500600301e200020a0b00000000000000000000000000000000000000000000000000000000000301f40500800301e2eda49bce2f38d284f839be1f4f2e23e6c7cc7dbd02007002021e0500a000050607080700000000000000000000000000000000000000000000000000000003023b0500800301e20500600200700200480500c002000000ec00f0000000004001740183018307002001b801be000006002001be01c1000008002001eb01f400000700200215021e00000300000232023b0000080020025c02680000030000026802710000";

        vm.prank(governor);
        harvester.setPriceProvider(address(0));

        uint256 balanceOSBefore = os.balanceOf(address(harvester));
        uint256 balanceWSBefore = ws.balanceOf(operator);
        assertGe(balanceOSBefore, 1 ether, "Balance of OS before swap should be >= 1");

        vm.startPrank(governor);
        harvester.swap(SonicHarvester.SwapPlatform.Magpie, address(os), 1e18, data);
        vm.stopPrank();
        uint256 balanceOSAfter = os.balanceOf(address(harvester));
        uint256 balanceWSAfter = ws.balanceOf(address(harvester));

        assertEq(balanceOSAfter, 0, "Balance of OS after swap should be 0");
        assertApproxEqRel(balanceWSAfter - balanceWSBefore, 1 ether, 1e16, "Balance of WS after swap should be 1");
    }
}
